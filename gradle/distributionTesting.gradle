/*
 * Copyright 2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import org.gradle.testing.DistributionTest
import org.gradle.util.GradleVersion

tasks.withType(DistributionTest) { DistributionTest task ->

    dependsOn ':toolingApi:toolingApiShadedJar'
    dependsOn ':cleanUpCaches'
    finalizedBy ':cleanUpDaemons'
    shouldRunAfter 'test'

    jvmArgs '-Xmx512m', '-XX:+HeapDumpOnOutOfMemoryError'
    if (!javaVersion.java8Compatible) {
        jvmArgs '-XX:MaxPermSize=768m'

    }

    reports.junitXml.destination = new File(project.testResultsDir, name)

    // use -PtestVersions=all or -PtestVersions=1.2,1.3â€¦
    if (project.hasProperty('testVersions')) {
        systemProperties['org.gradle.integtest.versions'] = project.testVersions
    }
    if (!systemProperties['org.gradle.integtest.versions']) {
        systemProperties['org.gradle.integtest.versions'] = 'latest'
    }

    systemProperties['org.gradle.integtest.cpp.toolChains'] = project.hasProperty("testAllPlatforms") && project.testAllPlatforms ? 'all' : 'default'

    systemProperties['org.gradle.integtest.multiversion'] = project.hasProperty("testAllVersions") && project.testAllVersions ? 'all' : 'default'

    def mirrorUrls = collectMirrorUrls()
    def mirrors = ['mavencentral', 'jcenter', 'lightbendmaven', 'ligthbendivy', 'google']
    mirrors.each { mirror ->
        systemProperties["org.gradle.integtest.mirrors.$mirror"] = mirrorUrls[mirror] ?: ''
    }

    dependsOn project.task("configure${task.name.capitalize()}") {
        doLast {
            configure(task) {
                reports.html.destination = file("${project.reporting.baseDir}/$name")
                gradleHomeDir = intTestImage.destinationDir
                gradleUserHomeDir = rootProject.file('intTestHomeDir')
                toolingApiShadedJarDir = rootProject.project(':toolingApi').toolingApiShadedJar.destinationDir

                if (requiresLibsRepo) {
                    libsRepo = rootProject.file('build/repo')
                }
                if (requiresDists) {
                    distsDir = rootProject.distsDir
                    systemProperties['integTest.distZipVersion'] = version
                }
                if (requiresBinZip) {
                    binZip = project(':distributions').binZip.archivePath
                }
                daemonRegistry = file("$rootProject.buildDir/daemon")
            }
        }
    }

    ext.daemonListener = null

    doFirst {
        def daemonPids = rootProject.cleanUpDaemons.daemonPids
        def suspiciousDaemons = rootProject.cleanUpDaemons.suspiciousDaemons
        daemonListener = [
            beforeTest : { test -> },
            afterTest  : { test, result -> },
            beforeSuite: { suite ->
                forEachJavaProcess { pid, process ->
                    // processes that exist before the test suite execution should
                    // not trigger a warning
                    daemonPids << pid
                }
            },
            afterSuite : { suite, result ->
                forEachJavaProcess { pid, process ->
                    if (!daemonPids.contains(pid)) {
                        daemonPids << pid
                        suspiciousDaemons."$suite" << pid
                    }
                }
            }] as TestListener
        gradle.addListener(daemonListener)
    }

    doLast {
        gradle.removeListener(daemonListener)
    }
}

def collectMirrorUrls() {
    // expected env var format: repo1_id:repo1_url,repo2_id:repo2_url,...
    System.getenv('REPO_MIRROR_URLS')?.split(',')?.collectEntries { nameToUrl ->
        def index = nameToUrl.indexOf(':')
        [(nameToUrl.substring(0, index)) : nameToUrl.substring(index + 1)]
    } ?: [:]
}

/**
 * Clean up cache files for older versions that aren't multi-process safe.
 */
def removeDodgyCacheFiles(File dir) {
   org.gradle.cleanup.Cleanup.removeDodgyCacheFiles(project, dir)
}

/**
 * Clean up daemon log files produced in integration tests.
 */
def removeDaemonLogFiles(File dir) {
    org.gradle.cleanup.Cleanup.removeDaemonLogFiles(project, dir)
}

/**
 * Removes state for versions that we're unlikely to ever need again, such as old snapshot versions.
 */
def removeOldVersionsFromDir(File dir, Spec<GradleVersion> shouldDelete, dirPrefix = "", dirSuffix = "") {
    org.gradle.cleanup.Cleanup.removeOldVersionsFromDir(project, dir, shouldDelete, dirPrefix, dirSuffix)
}

def removeCachedScripts(File cachesDir) {
    org.gradle.cleanup.Cleanup.removeCachedScripts(project, cachesDir)
}

project(":") {
    if (tasks.findByName('cleanUpCaches')) {
        return
    }

    task cleanUpCaches {
        dependsOn ':createBuildReceipt'
        doLast {
            def executingVersion = GradleVersion.version(gradle.gradleVersion)

            // Expire .gradle cache where major version is older than executing version
            def expireTaskCache = { candidateVersion ->
                return candidateVersion.baseVersion < executingVersion.baseVersion
            } as Spec<GradleVersion>

            // Expire intTestImage cache snapshots that are older than the tested version
            // Also expire version-specific cache snapshots when they can't be re-used (for 'snapshot-1' developer builds)
            def expireIntegTestCache = { candidateVersion ->
                return (candidateVersion.snapshot && candidateVersion < GradleVersion.version(version)) || candidateVersion.version.endsWith('-snapshot-1')
            } as Spec<GradleVersion>

            // Remove state for old versions of Gradle that we're unlikely to ever require again
            removeOldVersionsFromDir(file("buildSrc/.gradle"), expireTaskCache)
            removeOldVersionsFromDir(file(".gradle"), expireTaskCache)
            removeOldVersionsFromDir(file("intTestHomeDir/worker-1/caches"), expireIntegTestCache)

            // Remove scripts caches
            removeCachedScripts(file("intTestHomeDir/worker-1/caches"))
            // Remove script caches from TestKit integTest temp dir
            // location defined in TempTestKitDirProvider, copied here
            def testKitTmpDir = new File(new File(System.getProperty("java.io.tmpdir")), String.format(".gradle-test-kit-%s", System.getProperty("user.name")))
            removeCachedScripts(new File(testKitTmpDir, "caches"))

            removeOldVersionsFromDir(file("intTestHomeDir/worker-1/daemon"), expireIntegTestCache)

            // Remove old distributions used by wrapper that we're unlikely to ever require again
            removeOldVersionsFromDir(file("intTestHomeDir/worker-1/wrapper/dists"), expireIntegTestCache, "gradle-", "-bin")
            delete(file("intTestHomeDir/worker-1/wrapper/dists/dist"))

            // Remove caches that weren't multi-process safe and may be corrupt
            removeDodgyCacheFiles(file("intTestHomeDir/worker-1/caches"))

            // Remove old daemon log files
            removeDaemonLogFiles(file("intTestHomeDir/worker-1/daemon"))
        }
    }
}

def forEachJavaProcess(Closure action) {
    org.gradle.process.Process.forEachLeakingJavaProcess(project, { action.call(it.pid, it.process) } as Action)
}

def isMe(process) {
    org.gradle.process.Process.isMe(project, process)
}

def pkill(pid) {
    org.gradle.process.Process.pkill(project, pid)
}

project(":") {
    if (tasks.findByName('cleanUpDaemons')) {
        return
    }
    task killExistingProcessesStartedByGradle {
        doLast {
            def didKill = false
            forEachJavaProcess { pid, process ->
                logger.warn("A process wasn't shutdown properly in a previous Gradle run. Killing process with PID $pid (Command line: $process)")
                pkill(pid)
                didKill = true
            }
            if (didKill) {
                //it might take a moment until file handles are released
                Thread.sleep(5000)
            }
        }
    }

    task cleanUpDaemons {
        ext.suspiciousDaemons = [:].withDefault { [].asSynchronized() }.asSynchronized()
        ext.daemonPids = ([] as Set).asSynchronized()
        doLast {
            Set alreadyKilled = []
            forEachJavaProcess { pid, process ->
                suspiciousDaemons.each { suite, pids ->
                    if (pids.contains(pid) && !alreadyKilled.contains(pid)) {
                        logger.warn("A process was created in $suite but wasn't shutdown properly. Killing PID $pid (Command line: $process)")
                        pkill(pid)
                    }
                }
            }
        }
    }
    if (isCiServer) {
        clean.dependsOn killExistingProcessesStartedByGradle
        subprojects {
            tasks.all {
                mustRunAfter(killExistingProcessesStartedByGradle)
            }
        }
    }
}
